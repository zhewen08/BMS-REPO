\section{Design}

\subsection{Overview}

NDNREPO is based on graph database, which makes the design simple and elegant. The tree-style NDN hierarchical name naturally fits the graph representation. Therefore it is intuitive and effective to split a given NDN name into a sequence of components as nodes, and connecting them with simple relations that leads to the next component. The actual content object can be attached to the leaf component with another relation.

The root component of the NDN names, can be exploited to optimize searching the graph database. The graph database searches for requested patterns (node, relation, path) through traversing the graph, which could be done much more efficiently if the start node is known ahead. The root component of a NDN name (for now it is ``/ndn'', so we have only \emph{one} name tree in the graph database) serves as this start node perfectly and it is therefore natural to trace the requested content object following the name components in order.

\subsection{Nodes and Relations}

Nodes and relations, both can come with a type and multiple schema free properties, constitute the property graph database. We use a node to represent a name component and a relation to connect 2 name components.

For example, given 6-component name ``/ndn/ucla.edu/melnitz/1451/power/seg0'', we use accordingly 6 ``Component'' type nodes to represent each component with the ``component'' property that stores the component content. Specifically, node (root:Component \{component:``ndn''\}) is store in the graph database for the first (root) component. Similarly, node (comp:Component \{component:``ucla.edu''\}) is for the second component. To store the actual content object under this name, we exploit another ``Segment'' type node. This node is attached to the leaf ``Component'' node and has a ``file'' property whose content is Base64-encoded wired format object data. For instance, node (data:Segment \{file:``<Base64-endcoding-data>''\}) stores the actual content object in wire format.

2 types of relations are used to connect graph nodes. The ``CONTAINS_COMPONENT'' relation connects one name component to the next name component. One example is the relation connecting component \emph{root} and component \emph{comp} in above example. The ``CONTAINS_SEGMENT'' relation connects the leaf name component  to the actual content object data node. In above example component \emph{leaf} (leaf:Component \{component:``seg0''\}) and segment \emph{data}, which does not corresponds to any component in the name, are connected with this relation.

Differentiating nodes of components and nodes of content object data facilitates identifying the content of a node. The name/selectors based search is limited in the isolated name tree consisting of mere ``Component'' nodes connected by ``CONTAINS_COMPONENT'' relations.

\begin{itemize}
\item
Overview: Provide a brief overview at the beginning
\item
What, How, Why: For each component of the solution, clearly elaborate
   \begin{enumerate}
      \item
      What the issues/challenges to address?
      \item
      How the solution component works?
      \item
      Why choose such a solution approach?
      \item
      There are many ways to address the same issue, why this one? Provides cons and pros for this one
   \end{enumerate}
\item
Novelty, novelty, novelty!
Explain why the solution is different, not necessarily better
Tell readers why it is different from the related work when describing each component of the solution
\end{itemize} 